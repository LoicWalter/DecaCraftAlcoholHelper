@page "/"
@using Decacraft_AlcoholHelper.Services
@using Decacraft_AlcoholHelper.Models
@inject RecipesService RecipesService

<PageTitle>Recipe Calculator</PageTitle>
<MudContainer Style="margin: auto; max-width: 800px; min-height: 100vh; padding-block: 2rem">
    <MudText Typo="Typo.h2" Class="mb-4">Calculateur d'ingrédients</MudText>

    <MudAutocomplete T="string"
                     Label="Sélectionnez une recette"
                     @bind-Value="SelectedRecipeName"
                     @bind-Value:after="OnRecipeChanged"
                     SearchFunc="@SearchRecipes"
                     Variant="Variant.Outlined"
                     AdornmentIcon="@Icons.Material.Filled.Search"
                     AdornmentColor="Color.Primary"
                     Immediate="true"
                     Clearable="true"
                     ResetValueOnEmptyText="true"
                     CoerceText="true"
                     CoerceValue="true"
                     SelectValueOnTab="true"
                     MaxItems="null"
    />

    <MudNumericField @bind-Value="DesiredQuantity"
                     @bind-Value:after="OnQuantityChanged"
                     Label="Quantité désirée"
                     Variant="Variant.Outlined"
                     Min="1"
                     Max="9999"
                     Step="3"
                     Adornment="Adornment.End"
    />

    <MudSwitch @bind-Value="IncludeSubRecipes"
               @bind-Value:after="OnIncludeSubRecipesChanged"
               Color="Color.Primary"
               Label="Inclure les sous-recettes"
               Class="mt-2"
    />


    @if (OriginalRecipe != null)
    {
        <MudText Typo="Typo.h5" Class="my-3">
            Recette: @OriginalRecipe.Name
        </MudText>
        <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">
            Pour produire @DesiredQuantity unité(s), vous devez faire la recette @TimesToMake fois (chaque
            recette
            produit 3
            unités)
        </MudText>

        <MudDivider Class="mb-4"/>

        <MudText Typo="Typo.h6" Class="mb-3">
            Ingrédients nécessaires:
        </MudText>

        <MudList T="string">
            @foreach (var ingredientGroup in Ingredients.GroupBy(i => i.Type).OrderBy(g => g.Key))
            {
                <MudListSubheader>
                    <MudText Typo="Typo.subtitle1" Color="Color.Primary">
                        @(ingredientGroup.Key == IngredientType.Item ? "Items" : "Boissons")
                    </MudText>
                </MudListSubheader>

                @foreach (var ingredient in ingredientGroup.OrderBy(i => i.Quantity))
                {
                    <MudListItem T="string" Icon="@ingredient.GetIngredientIcon()">
                        <MudText>
                            <strong>@ingredient.Name</strong>
                            <MudChip T="string" Size="Size.Small" Color="Color.Info" Class="ml-2">
                                x@(ingredient.Quantity) @ingredient.GetStackText()
                            </MudChip>
                        </MudText>
                    </MudListItem>
                }
            }
        </MudList>

        <MudText Typo="Typo.h5" Class="my-3">
            Revenus estimés:
        </MudText>
        <MudText Typo="Typo.body2" Color="Color.Secondary" Class="mb-4">
            Le prix unitaire d'une bouteille est de @(OriginalRecipe.Value)Đ. Pour @DesiredQuantity unité(s), le revenu
            total estimé est de @(OriginalRecipe.Value * DesiredQuantity)Đ.
        </MudText>

        <MudDivider Class="my-4"/>
        @if (OriginalRecipe != null)
        {
            <MudText Typo="Typo.h6" Class="mb-3">
                Instructions:
            </MudText>

            <MudTimeline TimelineOrientation="TimelineOrientation.Vertical" TimelinePosition="TimelinePosition.Left">
                @foreach (var kvp in OriginalRecipe.GetInstructionsByRecipeName(IncludeSubRecipes))
                {
                    <MudTimelineItem Color="Color.Primary" Size="Size.Medium">
                        <ItemContent>
                            <MudText Typo="Typo.h6" Style="font-weight: bold; text-decoration: underline;">
                                Recette: @kvp.Key
                            </MudText>
                        </ItemContent>
                    </MudTimelineItem>
                    foreach (var instruction in kvp.Value)
                    {
                        <MudTimelineItem Color="@instruction.GetInstructionColor()" Size="Size.Small">
                            <ItemContent>
                                <MudText Typo="Typo.body1">
                                    <strong>@instruction.GetInstructionTitle()</strong>
                                </MudText>
                                <MudText Typo="Typo.body2" Color="Color.Secondary">
                                    @instruction.GetInstructionDescription(kvp.Key)
                                </MudText>
                            </ItemContent>
                        </MudTimelineItem>
                    }

                    <MudTimelineItem Color="Color.Success" Size="Size.Small">
                        <ItemContent>
                            <MudText Typo="Typo.body1" Style="font-weight: bold; text-decoration: underline;">
                                Scellez les bouteilles !
                            </MudText>
                        </ItemContent>
                    </MudTimelineItem>
                }
            </MudTimeline>
        }
    }
    else if (HasCalculated && !Ingredients.Any())
    {
        <MudAlert Severity="Severity.Warning">
            Aucun ingrédient trouvé pour cette recette.
        </MudAlert>
    }
</MudContainer>

@code {
    private List<string> _allRecipeNames = [];
    private string SelectedRecipeName { get; set; } = string.Empty;
    private int DesiredQuantity { get; set; } = 3;
    private bool IncludeSubRecipes { get; set; } = true;

    private List<Ingredient> Ingredients { get; set; } = [];
    private Recipe? OriginalRecipe { get; set; }
    private int TimesToMake { get; set; }
    private bool HasCalculated { get; set; }

    private void OnRecipeChanged()
    {
        if (string.IsNullOrEmpty(SelectedRecipeName) || !RecipesService.TryGetRecipeByName(SelectedRecipeName, out _))
        {
            return;
        }

        CalculateIngredients();
    }

    private void OnQuantityChanged()
    {
        CalculateIngredients();
    }

    private void OnIncludeSubRecipesChanged()
    {
        CalculateIngredients();
    }

    protected override async Task OnInitializedAsync()
    {
        await RecipesService.InitializeAsync();
        _allRecipeNames = RecipesService.GetAllRecipes()
            .Select(r => r.Name)
            .ToList();
    }

    private Task<IEnumerable<string>> SearchRecipes(string value, CancellationToken token)
    {
        return Task.FromResult(string.IsNullOrEmpty(value) ? _allRecipeNames.AsEnumerable() : _allRecipeNames.Where(x => x.Contains(value, StringComparison.InvariantCultureIgnoreCase)));
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        Console.WriteLine($"Parameters set: Recipe={SelectedRecipeName}, Quantity={DesiredQuantity}, IncludeSubRecipes={IncludeSubRecipes}");
        CalculateIngredients();
    }

    private void CalculateIngredients()
    {
        if (string.IsNullOrEmpty(SelectedRecipeName))
            return;

        try
        {
            Ingredients = RecipesService.GetIngredientsForRecipe(SelectedRecipeName, DesiredQuantity, IncludeSubRecipes);
            OriginalRecipe = RecipesService.GetRecipeByName(SelectedRecipeName);
            TimesToMake = (int)Math.Ceiling(DesiredQuantity / 3.0);
            HasCalculated = true;
        }
        catch (Exception)
        {
            Ingredients = [];
            OriginalRecipe = null;
            HasCalculated = true;
        }
    }
}
